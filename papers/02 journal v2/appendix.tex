\appendix[Supplementary Material ]
\subsection{Algorithm 1: Derivation and Convergence Analysis}
\label{app:CA}
The derivation and convergence analysis of Algorithm 1 relies (for the most part) on the \textit{customized preconditioned proximal-point (cPPP)} algorithm for generalized aggregative games proposed in \cite[Algorithm~6]{belgioioso2020semi}. The objective of this appendix is to show that the proposed market-clearing game \eqref{eq:locOpt}, with cost functions and constraints sets defined in \eqref{eq:cost_def}-\eqref{eq:Cconstr_def}, satisfies all the technical conditions in \cite[Theorem~2]{belgioioso2020semi}, among which is the existence of a variational GNE, i.e., item (i) of Proposition \ref{prp:conv}. Therefore, we invoke \cite[Theorem~2]{belgioioso2020semi} to prove convergence of Algorithm \ref{alg:alg1}, i.e., item (ii) of Proposition \ref{prp:conv}. For a complete convergence analysis of the cPPP algorithm for aggregative games we refer to \cite[Appendix~C]{belgioioso2020semi}.

\smallskip
\subsubsection*{Aggregative cost functions} First, we show that the cost functions \eqref{eq:cost_def} can be cast as in\cite[Eqn.~(30)]{belgioioso2020semi}, i.e.
\begin{equation}
	\label{eq:cFcPPP}
	J_i(u_i, u_{-i}) = g_i(u_i) + {(C \avg( u))}^\top u_i,
\end{equation}
where $\avg( u) := \frac{1}{N}\sum_{i \in \mc N} u_i$ denotes the average strategy.
Let $\mc N_i = \mc N$, for all $i \in \mc N$, without loss of generality\footnote{For example, by defining, for all $i \in \mc N$, the ``dummy variables" $\{p^{\text{tr}}_{(i,j)}\}_{j \in \mc N \setminus {\mc N_i}}$ for all the prosumers that do not trade with $i$.}. In this case, $u_i \in \R^{(3+N)H}$, for all $i \in \mc N$. Moreover, let $\Xi^{\text{mg}} \in \R^{H \times (3+N)H}$ denote the matrix that selects the $p_{i}^{\text{mg}}$-component from the decision vectors $u_i$'s, and define the matrix $D:= N \diag(d^{\text{mg}}_1, \ldots, d^{\text{mg}}_H)$, where $d^{\text{mg}}_h$ is the price coefficient for the main grid power. Then, the cost functions in \eqref{eq:cost_def} can be recast as \cite[Eqn.~(30)]{belgioioso2020semi}, or \eqref{eq:cFcPPP}, with
\begin{subequations}
	\label{eq:pieces_cPPP}
	\begin{align}
		g_i(u_i) &= \nonumber
		f_{i}^{\mathrm{di}}(p_{i}^{\mathrm{di}}) + f_{i}^{\mathrm{st}}(p_{i}^{\mathrm{st}})+ f_{i}^{\mathrm{tr}} \left( \{ p_{(i,j)}^{\mathrm{tr}} \}_{j \in \mc N_i} \right),\\[-.2em]
		\label{eq:gi_cPPP}
		&
		\textstyle
		\quad +\frac{1}{N}(Db)^\top p_i^{\text{mg}},\\[.2em]
		%
		C &= (\Xi^{\text{mg}})^\top D \, \Xi^{\text{mg}}.
		\label{eq:C_cPPP}
	\end{align}
\end{subequations}


\subsubsection*{Technical assumptions} Next, we show that all the assumptions in \cite[Theorem~2]{belgioioso2020semi} are satisfied.
\begin{enumerate}[(i)]
	\item For all $i \in \mc N^+$, the cost function $J_i(u_i, u_{-i})$ in \eqref{eq:gi_cPPP} is convex in $u_i$, since all the components of $g_i$ are convex. Hence, \cite[Assumption~1]{belgioioso2020semi} holds.
	%
	\item For all $i \in \mc N^+$, the local set $\mc U_i$ in \eqref{eq:constr_def} is nonempty, closed and convex. Moreover, Slater's constraint qualification on the global feasible set $\left( \prod_{i \in \mc N^+} \mc U_i \right) \cap \mc C$ holds under an appropriate choice of the parameters. Therefore, \cite[Assumption~2]{belgioioso2020semi} is satisfied.
	%
	\item The \textit{pseudo-subdifferential} mapping of the game \eqref{eq:locOpt} reads as $F: u \mapsto \prod_{i \in \mc N}\left(\partial_{u_i} J_i(u_i, u_{-i})\right)\times \0$, since $J_{N+1}=0$. It follows by \cite[Corollary~1]{belgioioso2017convexity}, that the first term of $F$, i.e., $u \mapsto \prod_{i \in \mc N}\partial_{u_i} J_i(u_i, u_{-i})$, is maximally monotone, since  $C$ in \eqref{eq:C_cPPP} is positive semidefinite, i.e., $C=(\Xi^{\text{mg}})^\top D \, \Xi^{\text{mg}} \succeq 0$. Moreover, also the second term of $F$, i.e., the zero mapping $\0$, is maximally monotone. Therefore, it follows by \cite[Proposition~20.23]{bauschke2011convex} that their cartesian product $\prod_{i \in \mc N}\left(\partial_{u_i} J_i(u_i, u_{-i})\right)\times \0 = F$ is maximally monotone. Hence, \cite[Assumption~6]{belgioioso2020semi} holds.
	%
	\item By \cite[Lemma~1~(i)]{belgioioso2020semi}, there exists a variational GNE of the game in \eqref{eq:locOpt}, since the constraint sets $\mc U_i$ in \eqref{eq:constr_def} are bounded, and the pseudo-subdifferential mapping $F$ is monotone. Hence, \cite[Assumption~4]{belgioioso2020semi} is satisfied.
\end{enumerate} 
{\hfill $\blacksquare$}
%\subsection*{Step-size selection}
%\blue{to complete}.


\subsection{Alternating Projection for Operational Feasibility}
\label{APA}
In this appendix, we propose an efficient algorithm to compute the projection onto the set $\mathcal{U}_{N+1}$  (line 30 in Algorithm~\ref{alg:alg1}). First, let us recall the structure of $u_{N+1}$, i.e.,
$$u_{N+1}=\col\left(\{\theta_y, v_y, p_y^{\mathrm{tg}},\{p_{(y,z)}^{\ell},q_{(y,z)}^{\ell}\}_{z \in \mc B_y} \}_{y\in\mc B} \right),$$ and let us define the sets
\begin{align}
	\mc S_1 &:= \{u_{N+1} \mid \text{\eqref{eq:line} and \eqref{eq:grid_ex} hold}\},\\
	%
	\mc S_2 &:= \{u_{N+1} \mid \text{\eqref{eq:pf_p} and \eqref{eq:pf_q} hold}\},
\end{align}
such that $\mathcal{U}_{N+1} = \mc S_1 \cap \mc S_2$. 
%
The proposed method, summarized in Algorithm~\ref{alg:alg2}, is essentially a \textit{Douglas--Rachford splitting} (DRS) \cite[\S~26.3]{bauschke2011convex} applied to the \textit{best approximation problem} $ {\argmin}_{\xi \in \mc S_1 \cap \mc S_2}  \|\xi-u_{N+1}\| =\proj_{\mc S_1 \cap \mc S_2}(u_{N+1}) $, see e.g. \cite[\S~4.3]{bauschke2015projection} for a formal derivation of the algorithm.

%
Unlike $\mc U_{N+1}$, the projections onto $\mc S_1$ and $\mc S_2$ have closed-form expressions, hence Algorithm \ref{alg:alg2} only involves elementary operations. Specifically,
%\begin{align*}
$	\proj_{\mc S_1}(u_{N+1})=
u_{N+1}^+$, where
\begin{align*}
	\theta_y^+ &=
	\begin{cases}
		\underline{\theta}_y, & \text{if } \theta_y < \underline{\theta}_y\\
		\overline{\theta}_y, & \text{if } \theta_y > \overline{\theta}_y\\
		\theta_y, & \text{otherwise } \
	\end{cases}, \quad \
	%
	v_y^+ = 
	\begin{cases}
		\underline{v}_y, & \text{if } v_y < \underline{v}_y\\
		\overline{v}_y, & \text{if } v_y > \overline{v}_y\\
		v_y, & \text{otherwise } \
	\end{cases},
	\\
	%
	{p_y^{\text{tg}}}^+ &= 
	\begin{cases}
		p_y^{\text{tg}}, & \text{if } y \in \mc B^{\text{mg}}\\
		0, & \text{otherwise} 
	\end{cases},
\end{align*}
and for all $y \in \mc B$, $z \in \mc B_z$, and  $h \in \mc H$
\begin{align*}
	\begin{array}{l}
		L_{(y,z),h} = \max \left\{ \|\col(p^\ell_{(y,z),h} , q^\ell_{(y,z),h} \|, \, \overline{s}_{(y,z)} \right\},\\[.2em]
		%
		{(p^\ell_{(y,z),h})}^+  = \tfrac{\overline{s}_{(y,z)}}{
			L_{(y,z),h}
		}\,  p^\ell_{(y,z),h}, \\[.2em]
		%
		{(q^\ell_{(y,z),h})}^+  = \tfrac{\overline{s}_{(y,z)}}{
			L_{(y,z),h}
		}\, q^\ell_{(y,z),h}.
	\end{array}
\end{align*}
Whereas, since $\mc S_2$ is an affine set, a closed-form expression for $\proj_{\mc S_2}$ is given in \cite[Example 29.17(ii)]{bauschke2011convex}.
%The projection onto $C_2$ can be computed by solving a quadratic programming (e.g. via lsqlin, quadprog, osqp, etc...) with appropriate matrices.

%%%%%%%%
\algblockdefx[init]{init}{Endinit}
[1][<default value>]{\textbf{Initialization}}
[2][<default value>]{\textbf{end initialization}}

\algblockdefx[DNO]{DNO}{EndDNO}
[1][<default value>]{\textbf{DNO routine}}
[2][<default value>]{\textbf{end DNO routine}}

\algblockdefx[PRO]{PRO}{EndPRO}
[1][<default value>]{\textbf{Prosumer $i$ routine}}
[2][<default value>]{\textbf{end prosumer $i$ routine}}

\algblockdefx[Primal]{Primal}{EndPrimal}
[1][<default value>]{\textbf{primal update}}
[2][<default value>]{\textbf{end}}

\algblockdefx[Dual]{Dual}{EndDual}
[1][<default value>]{\textbf{dual update}}
[2][<default value>]{\textbf{end}}

\algblockdefx[Aux]{Aux}{EndAux}
[1][<default value>]{\textbf{auxiliary update}}
[2][<default value>]{\textbf{end}}

\algblockdefx[Comm]{Comm}{EndComm}
[1][<default value>]{\textbf{communication}}
[2][<default value>]{\textbf{end communication}}

\algblockdefx[Agg]{Agg}{EndAgg}
[1][<default value>]{\textbf{aggregation update}}
[2][<default value>]{\textbf{end}}

\algblockdefx[IUC]{IUC}{EndIUC}
[1][<default value>]{\textbf{While convergence is not achieved do:}}
[2][<default value>]{\textbf{end while}}
%%%%%%%%%%

\begin{algorithm}[]
	\caption{DRS for computing $\proj_{\mc U_{N+1}}(u_{N+1})$}
	\label{alg:alg2}
	\begin{algorithmic}[1]
		
		\smallskip
		\State Initialize $\xi(0) \in \bb R^{n_{N+1}}$, and set $\eta \in (0,2)$
		\IUC{ }
		
		\smallskip
		\State
		$z(k) = \proj_{\mc S_1}(\frac{1}{2} \xi(k) + \frac{1}{2} u_{N+1})$ 
		
		
		\smallskip
		\State
		$\xi(k+1) = \xi(k) + \eta \left( \proj_{\mc S_2}    (2z(k)-\xi(k)) - z(k)
		\right)$
		\EndIUC
		
	\end{algorithmic}
\end{algorithm}

\smallskip	

\begin{algorithm*}[htbp]
\caption{Semi-decentralized P2P Markets Clearing Mechanism}
\label{alg:alg1}
\begin{algorithmic}[1]
\small

\init{ }
\State
\textbf{Prosumers.} For all $i \in \mc N$: set $u_i(0) \in \mc U_i$, $\mu^{\text{tr}}_{(i,j)}(0) = \0$, $\forall j \in \mc N_i$; $\alpha_i \!<\! 
(\red{3} +N \underset{h\in \mc H}{\max}\, d_h^{\text{mg}})^{-1}$, $\beta^{\text{tr}}_{(i,j)}\! =\! \beta^{\text{tr}}_{ (j,i)} \!<\! \frac{1}{2}$, $\forall j \!\in\! \mc N_i$.
\State
\textbf{DNO.} Set $u_{N+1}(0) \!\in\! \mc U_{N+1}$, $\lambda^{\text{mg}}\!=\!\0$, $\mu^{\text{tg}} \!=\! \0$, $\mu_y^{\text{pb}}(0)\! = \!\0$, $\forall y \!\in\! \mc B$; $\alpha_{N+1} \!<\!2$, $\gamma^{\text{mg}} \!<\! \frac{1}{N}$, $\beta^{\text{tg}}\! <\! \frac{1}{|\mc N| \!+\! |\mc B|}$, $\beta_y^{\text{pb}} \!<\! \frac{1}{1\!+\!2|\mc N_y^{\mathrm{b}}|\!+\!|\mc B_y|}$,  $\forall y\!\in\! \mc B $.%

\Endinit

\smallskip
\IUC{ }
\smallskip
\ForAll{$ i \in \mc N$}
\PRO{ }
\Primal{ }
\Comment{$u_i = \{$generation, storage, main grid, trades$\}$}

\smallskip
\State 
$\psi_i(k) = 
	\col \Big(-\mu_y^{\text{pb}}(k),\edit{\mu_y^{\text{pb}}(k), -\mu_y^{\text{pb}}(k),}
	{
	%\left(
	\left[
	\begin{smallmatrix}
	I_H\\
	- I_H 
	\end{smallmatrix}
	\right] 
	%\otimes I_H
%\right)	
	}^\top \lambda^{\text{mg}}(k) + \mu^{\text{tg}}(k),
	%
	\left\{ {\mu^{\text{tr}}_{(i,j)}(k)}\right\}_{j \in \mc N_i}   \Big)$
\Comment{auxiliary vector}

\State
$u_i(k+1)   =
\left\{
\begin{array}{r l}
	\underset{\xi \in \R^{n_i}}{\argmin} & 
	\tilde J_{i} \big( \xi, \sigma^{\text{mg}}(k) \big) 
	+ {\psi_i(k)}^\top \xi + \frac{1}{2 \alpha_i}
	\left\| \xi - u_i(k) 
	\textstyle
	  \right\|^2 \\
	\text{s.t. } & \xi \in \mc U_i
\end{array} 
	\right.	$
\Comment{quadratic programming}	
\EndPrimal

\Comm{ (to DNO and trading partners)}
\State $\eta_i(k+1)= p^{\text{d}}_i-p^{\text{di}}_i(k+1)\edit{+p^{\text{ch}}_i(k+1)- p^{\text{ds}}_i(k+1)}$
\Comment{auxiliary vector: local load unbalance}
\State
$
p^{\textrm{mg}}_{i}(k+1), \eta_i(k+1)  \longrightarrow  \text{DNO,}
$
\Comment{forward to DNO}
     \ForAll{prosumer $ j \in \mc N_i$}
     
\State
 $p^{\text{tr}}_{(i,j)}(k+1)
	\longrightarrow \text{prosumer }j$
	\Comment{forward trade estimate to prosumer $j$}
	\EndFor
\EndComm


\Dual{ }
\Comment{reciprocity constraints}
\ForAll{$ j \in \mc N_i$}
\State
$\zeta^{\text{tr}}_{(i,j)}(k+1)  =  p^{\textrm{tr}}_{(i,j)} (k+1) + p^{\textrm{tr}}_{(j,i)} (k+1)$
\Comment{auxiliary vector}
\State
$\mu^{\text{tr}}_{(i,j)}(k+1) = \mu^{\text{tr}}_{(i,j)}(k) + \beta_{(i,j)}^{\text{tr}} \left( 
	2  \zeta^{\text{tr}}_{(i,j)}(k+1) - \zeta^{\text{tr}}_{(i,j)}(k)
	\right)$
	\Comment{reflected dual ascent}
\EndFor

\EndDual

\EndPRO

\EndFor

%%%%%%%%%%%%%%%%%%%%%%
\smallskip
%\Statex
\DNO{ }
%\State
%Iterate

\Primal{}
\Comment{angles, voltages, power on grid and buses}
\State
$\psi_{N+1}(k) = \col \left( 
	\left\{
	\0,\0,-\mu^{\text{tg}}(k) - \mu_y^{\text{pb}}(k), 
	\{ -\mu_y^{\text{pb}}(k), \0 \}_{z \in \mc B_y}
	\right\}_{y \in \mc B}
	\right)$
\Comment{auxiliary vector}

\State 	$u_{N+1}(k+1) = \proj_{\mc U_{N+1}}  \left( u_{N+1}(k) - (\alpha_{N+1})^{-1} \psi_{N+1}(k) \right)$
%\Comment{ solved via Algorithm 2 (see Appendix)}
\EndPrimal

%---------------------------Aggregation
\Agg{}
\State
$ \sigma^{\text{mg}}(k+1) = \sum_{i \in \mc N} p_i^{\text{mg}}(k+1) $
\Comment{aggregate active load, eqn. (10)}
\State
$\sigma^{\text{tg}}(k+1) = \sum_{y \in \mc B} p_y^{\text{tg}}(k+1)$
\Comment{aggregate grid-to-buses power }
\EndAgg

%---------------------------Dual Update
\Dual{}
\State
$\eta_{N+1}(k+1	) = 
	\left[
	\begin{smallmatrix}
	1\\
	- 1 
	\end{smallmatrix}
	\right] \otimes (2 \sigma^{\text{mg}}(k+1)- \sigma^{\text{mg}}(k)) 
	-
	\left[
	\begin{smallmatrix}
	\overline{p}^{\mathrm{mg}}\1_{H}-b \\
	-     \underline{p}^{\mathrm{mg}} \1_{H}+b
	\end{smallmatrix} 
	\right]  $
	\Comment{auxiliary vector}
	\State
$\lambda^{\text{mg}}(k+1) = \textstyle
	\proj_{\R^{2 H}_{\geq 0}}\left( 
	\lambda^{\text{mg}}(k) + \gamma^{\text{mg}} \eta_{N+1}(k+1)
	 \right)$
		\Comment{grid constraints}

\ForAll{buses $ y \in \mc B$}

\State
$\zeta^{\text{pb}}_y(k+1)   = \sum_{i \in \mc P_y^{\mathrm{b}}} p_i^{\mathrm{d}} + \sum_{i \in \mc N_y^{\mathrm{b}}} \eta_i(k+1)- p^{\text{tg}}_y(k+1) - \sum_{z \in \mc B_y} p^\ell_{(y,z)} (k+1)$
\Comment{auxiliary vector}

\State
$\mu_y^{\text{pb}}(k+1) = \mu_y^{\text{pb}}(k) + \beta^{\text{pb}}_y (2 \zeta^{\text{pb}}_y(k+1)- \zeta^{\text{pb}}_y(k))$
\Comment{local power balance of bus $y$}
\EndFor

\State
$\zeta^{\text{tg}}(k+1) = \sigma^{\text{mg}}
	(k+1)+b- \sigma^{\text{tg}}(k+1)$
\Comment{auxiliary vector}

\State
$\mu^{\text{tg}}(k+1) = \mu^{\text{tg}}(k) + \beta^{\text{tg}} (2\zeta^{\text{tg}}(k+1)-\zeta^{\text{tg}}(k))$
\Comment{grid-to-buses constraints}
\EndDual	

\Comm{ (broadcast to all prosumers)}
\State
$ \{ \sigma^{\mathrm{mg}}(k+1)+b, \, \lambda^{\text{mg}}(k+1), \mu^{\text{tg}}(k+1) \} 
	\longrightarrow  \mc N$
\ForAll{buses $ y \in \mc B$}
\State
$\mu^{\text{pb}}_y(k+1)\longrightarrow \mc N_y^{\mathrm{b}}$
\Comment{only to prosumers on bus $y$}
\EndFor

\EndComm

\EndDNO	

\EndIUC	

\end{algorithmic}
\end{algorithm*}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%